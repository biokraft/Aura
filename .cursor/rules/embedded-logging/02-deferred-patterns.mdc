---
description: Deferred logging implementation: Apply when implementing logging systems that need real-time performance
globs: **/*.c, **/*.cpp, **/*.h, **/*.hpp
alwaysApply: false
---
# Deferred Logging Implementation

## Core Architecture

Deferred logging separates the logging process into two distinct stages to maintain real-time performance:

1. **Capture Stage (Fast)**: Minimal work in time-critical code
2. **Processing Stage (Deferred)**: String formatting and I/O in background

## Implementation Pattern

### Basic Ring Buffer Structure

```c
typedef struct {
    uint32_t id;          // Log message ID or timestamp
    uint32_t level;       // Log level
    void* data;           // Raw parameter data
    size_t data_size;     // Size of parameter data
} log_entry_t;

typedef struct {
    log_entry_t* buffer;
    volatile size_t head;
    volatile size_t tail;
    size_t capacity;
    volatile bool overflow;
} ring_buffer_t;
```

### Fast Capture Function

```c
// Called from ISR or time-critical code
static inline bool log_capture(ring_buffer_t* rb, uint32_t id, 
                              uint32_t level, const void* data, size_t size) {
    // Disable interrupts briefly
    uint32_t irq_state = disable_interrupts();
    
    size_t next_head = (rb->head + 1) % rb->capacity;
    if (next_head == rb->tail) {
        rb->overflow = true;
        restore_interrupts(irq_state);
        return false; // Buffer full
    }
    
    // Copy data quickly
    log_entry_t* entry = &rb->buffer[rb->head];
    entry->id = id;
    entry->level = level;
    entry->data_size = size;
    
    if (size <= MAX_INLINE_DATA) {
        memcpy(entry->data, data, size);
    } else {
        // For large data, store pointer (careful with lifetime)
        entry->data = (void*)data;
    }
    
    rb->head = next_head;
    restore_interrupts(irq_state);
    return true;
}
```

### Background Processing

```c
// Called from low-priority task or main loop
void process_log_entries(ring_buffer_t* rb) {
    while (rb->tail != rb->head) {
        log_entry_t* entry = &rb->buffer[rb->tail];
        
        // Format and output the log message
        format_and_output_log(entry);
        
        rb->tail = (rb->tail + 1) % rb->capacity;
    }
    
    if (rb->overflow) {
        output_overflow_warning();
        rb->overflow = false;
    }
}
```

## C++ Implementation with Templates

```cpp
template<size_t BufferSize = 1024>
class DeferredLogger {
private:
    struct LogEntry {
        uint32_t timestamp;
        LogLevel level;
        uint16_t format_id;
        std::array<uint8_t, 32> params;
        uint8_t param_size;
    };
    
    std::array<LogEntry, BufferSize> buffer_;
    std::atomic<size_t> head_{0};
    std::atomic<size_t> tail_{0};
    
public:
    // Fast capture - safe for ISR
    template<typename... Args>
    bool log(LogLevel level, uint16_t format_id, Args&&... args) {
        LogEntry entry;
        entry.timestamp = get_timestamp();
        entry.level = level;
        entry.format_id = format_id;
        
        // Serialize parameters into fixed buffer
        if (!serialize_params(entry.params, entry.param_size, args...)) {
            return false; // Parameters too large
        }
        
        // Atomic insertion
        size_t current_head = head_.load();
        size_t next_head = (current_head + 1) % BufferSize;
        
        if (next_head == tail_.load()) {
            return false; // Buffer full
        }
        
        buffer_[current_head] = entry;
        head_.store(next_head);
        return true;
    }
    
    // Background processing
    void process_pending() {
        size_t current_tail = tail_.load();
        size_t current_head = head_.load();
        
        while (current_tail != current_head) {
            const LogEntry& entry = buffer_[current_tail];
            output_formatted_log(entry);
            current_tail = (current_tail + 1) % BufferSize;
        }
        
        tail_.store(current_tail);
    }
};
```

## Best Practices

### Memory Management
- Use static allocation for log buffers
- Avoid dynamic allocation in fast path
- Consider memory alignment for performance

### Thread Safety
- Use atomic operations for head/tail pointers
- Minimize interrupt disable time
- Consider lock-free algorithms for multi-core systems

### Overflow Handling
- Detect and report buffer overflows
- Consider dropping oldest entries vs. newest
- Size buffers based on worst-case scenarios

### Parameter Handling
- Serialize parameters immediately in fast path
- Avoid storing pointers to stack variables
- Use type-safe serialization for C++

## Integration with RTOS

```c
// FreeRTOS example
void log_processing_task(void* params) {
    TickType_t last_wake = xTaskGetTickCount();
    
    while (1) {
        process_log_entries(&global_log_buffer);
        
        // Process logs every 10ms
        vTaskDelayUntil(&last_wake, pdMS_TO_TICKS(10));
    }
}
```

## Performance Considerations

- **Capture overhead**: Should be < 10 CPU cycles in optimal case
- **Buffer sizing**: Balance memory usage vs. overflow risk
- **Processing frequency**: Match to system requirements
- **Interrupt latency**: Minimize time with interrupts disabled
description:
globs:
alwaysApply: false
---

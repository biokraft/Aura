---
description: Logging levels and configuration: Apply when implementing log level systems and runtime configuration
globs: **/*.c, **/*.cpp, **/*.h, **/*.hpp
alwaysApply: false
---
# Logging Levels and Configuration

## Standard Log Levels

Implement a hierarchical logging system with these standard levels:

### Level Definitions

```c
typedef enum {
    LOG_LEVEL_ERROR   = 0,  // Critical failures that may compromise system
    LOG_LEVEL_WARNING = 1,  // Unexpected events that don't represent errors yet
    LOG_LEVEL_INFO    = 2,  // High-level status messages for normal operation
    LOG_LEVEL_DEBUG   = 3,  // Detailed information for debugging
    LOG_LEVEL_TRACE   = 4   // Very detailed execution traces
} log_level_t;
```

### Usage Guidelines

- **ERROR**: System failures, hardware faults, security violations
- **WARNING**: Resource exhaustion warnings, configuration issues, recoverable errors
- **INFO**: Startup sequences, mode changes, significant state transitions
- **DEBUG**: Function entry/exit, parameter values, algorithm steps
- **TRACE**: Loop iterations, detailed state machine transitions, timing measurements

## Compile-Time Filtering

### Preprocessor-Based Filtering

```c
// In config.h or build system
#define LOG_COMPILE_LEVEL LOG_LEVEL_INFO

// In logging implementation
#define LOG_ERROR(fmt, ...)   \
    do { \
        if (LOG_LEVEL_ERROR <= LOG_COMPILE_LEVEL) { \
            log_write(LOG_LEVEL_ERROR, fmt, ##__VA_ARGS__); \
        } \
    } while(0)

#define LOG_WARNING(fmt, ...) \
    do { \
        if (LOG_LEVEL_WARNING <= LOG_COMPILE_LEVEL) { \
            log_write(LOG_LEVEL_WARNING, fmt, ##__VA_ARGS__); \
        } \
    } while(0)

#define LOG_INFO(fmt, ...)    \
    do { \
        if (LOG_LEVEL_INFO <= LOG_COMPILE_LEVEL) { \
            log_write(LOG_LEVEL_INFO, fmt, ##__VA_ARGS__); \
        } \
    } while(0)

#define LOG_DEBUG(fmt, ...)   \
    do { \
        if (LOG_LEVEL_DEBUG <= LOG_COMPILE_LEVEL) { \
            log_write(LOG_LEVEL_DEBUG, fmt, ##__VA_ARGS__); \
        } \
    } while(0)
```

### Benefits of Compile-Time Filtering

- Zero runtime overhead for disabled levels
- Reduces code size significantly
- Eliminates parameter evaluation for disabled logs
- Compiler can optimize away entire log calls

## Runtime Configuration

### Global Runtime Level

```c
static volatile log_level_t runtime_log_level = LOG_LEVEL_INFO;

bool log_should_output(log_level_t level) {
    return level <= runtime_log_level;
}

void log_set_level(log_level_t level) {
    runtime_log_level = level;
}

log_level_t log_get_level(void) {
    return runtime_log_level;
}
```

### Per-Module Configuration

```c
typedef struct {
    const char* module_name;
    log_level_t level;
} module_log_config_t;

static module_log_config_t module_configs[] = {
    {"UART",    LOG_LEVEL_WARNING},
    {"SPI",     LOG_LEVEL_INFO},
    {"TIMER",   LOG_LEVEL_DEBUG},
    {"SENSOR",  LOG_LEVEL_ERROR},
};

bool log_module_should_output(const char* module, log_level_t level) {
    for (size_t i = 0; i < ARRAY_SIZE(module_configs); i++) {
        if (strcmp(module_configs[i].module_name, module) == 0) {
            return level <= module_configs[i].level;
        }
    }
    return level <= runtime_log_level; // Fallback to global
}
```

## C++ Template-Based Implementation

```cpp
template<LogLevel CompileLevel = LogLevel::INFO>
class Logger {
private:
    static inline LogLevel runtime_level_ = LogLevel::INFO;
    const char* module_name_;

public:
    explicit Logger(const char* module) : module_name_(module) {}
    
    template<LogLevel Level, typename... Args>
    void log(const char* format, Args&&... args) {
        // Compile-time check eliminates code if level too high
        if constexpr (Level <= CompileLevel) {
            // Runtime check for dynamic control
            if (Level <= runtime_level_) {
                log_output(Level, module_name_, format, std::forward<Args>(args)...);
            }
        }
    }
    
    template<typename... Args>
    void error(const char* format, Args&&... args) {
        log<LogLevel::ERROR>(format, std::forward<Args>(args)...);
    }
    
    template<typename... Args>
    void warning(const char* format, Args&&... args) {
        log<LogLevel::WARNING>(format, std::forward<Args>(args)...);
    }
    
    static void set_runtime_level(LogLevel level) {
        runtime_level_ = level;
    }
};

// Usage
static Logger<LogLevel::DEBUG> sensor_log("SENSOR");
sensor_log.debug("Temperature reading: %d", temp_value);
```

## Configuration Sources

### Environment-Based Configuration

```c
void log_init_from_environment(void) {
    // Read from environment variable or configuration file
    const char* level_str = getenv("LOG_LEVEL");
    if (level_str) {
        if (strcmp(level_str, "ERROR") == 0) {
            log_set_level(LOG_LEVEL_ERROR);
        } else if (strcmp(level_str, "WARNING") == 0) {
            log_set_level(LOG_LEVEL_WARNING);
        } else if (strcmp(level_str, "INFO") == 0) {
            log_set_level(LOG_LEVEL_INFO);
        } else if (strcmp(level_str, "DEBUG") == 0) {
            log_set_level(LOG_LEVEL_DEBUG);
        }
    }
}
```

### Serial Console Configuration

```c
void process_log_command(const char* command) {
    if (strncmp(command, "log_level ", 10) == 0) {
        const char* level_str = command + 10;
        
        if (strcmp(level_str, "error") == 0) {
            log_set_level(LOG_LEVEL_ERROR);
            printf("Log level set to ERROR\n");
        } else if (strcmp(level_str, "warning") == 0) {
            log_set_level(LOG_LEVEL_WARNING);
            printf("Log level set to WARNING\n");
        } else if (strcmp(level_str, "info") == 0) {
            log_set_level(LOG_LEVEL_INFO);
            printf("Log level set to INFO\n");
        } else if (strcmp(level_str, "debug") == 0) {
            log_set_level(LOG_LEVEL_DEBUG);
            printf("Log level set to DEBUG\n");
        } else {
            printf("Invalid log level. Use: error, warning, info, debug\n");
        }
    }
}
```

## Advanced Configuration Features

### Time-Based Level Changes

```c
typedef struct {
    uint32_t start_time_ms;
    uint32_t duration_ms;
    log_level_t temporary_level;
} temporary_log_config_t;

static temporary_log_config_t temp_config = {0};

void log_enable_temporary_level(log_level_t level, uint32_t duration_ms) {
    temp_config.start_time_ms = get_system_time_ms();
    temp_config.duration_ms = duration_ms;
    temp_config.temporary_level = level;
}

log_level_t log_get_effective_level(void) {
    if (temp_config.duration_ms > 0) {
        uint32_t elapsed = get_system_time_ms() - temp_config.start_time_ms;
        if (elapsed < temp_config.duration_ms) {
            return temp_config.temporary_level;
        } else {
            temp_config.duration_ms = 0; // Expire temporary config
        }
    }
    return runtime_log_level;
}
```

### Conditional Logging

```c
#define LOG_IF(condition, level, fmt, ...) \
    do { \
        if ((condition) && log_should_output(level)) { \
            log_write(level, fmt, ##__VA_ARGS__); \
        } \
    } while(0)

#define LOG_EVERY_N(n, level, fmt, ...) \
    do { \
        static uint32_t count = 0; \
        if ((++count % (n)) == 0 && log_should_output(level)) { \
            log_write(level, fmt " (count: %u)", ##__VA_ARGS__, count); \
        } \
    } while(0)

// Usage examples
LOG_IF(sensor_fault_detected, LOG_LEVEL_ERROR, "Sensor fault in module %d", module_id);
LOG_EVERY_N(100, LOG_LEVEL_INFO, "Heartbeat");
```

## Performance Optimization

### Branch Prediction Hints

```c
#define LIKELY(x)   __builtin_expect(!!(x), 1)
#define UNLIKELY(x) __builtin_expect(!!(x), 0)

#define LOG_FAST_CHECK(level) UNLIKELY(log_should_output(level))
```

### Atomic Operations for Thread Safety

```c
#include <stdatomic.h>

static atomic_int runtime_log_level = ATOMIC_VAR_INIT(LOG_LEVEL_INFO);

void log_set_level_atomic(log_level_t level) {
    atomic_store(&runtime_log_level, level);
}

bool log_should_output_atomic(log_level_t level) {
    return level <= atomic_load(&runtime_log_level);
}
```
description:
globs:
alwaysApply: false
---
